	asect 0x00

    while
        ldi r2, keyboard
        tst r2 # practically infinite loop
    stays nz
        ld r2, r2

        ldi r0, player_offset
        ld r0, r1

        if 
            tst r2
        is z
            ldi r0, player_offset
            ld r0, r0

            ldi r1, player_byte
            ld r1, r1

            jmp draw
        fi 

        ldi r3, 1

        if
            shr r2
        is cs
            neg r3
        fi

        ldi r2, player_byte
        ld r2, r1
        if
            shr r2
        is cs
            # Shift the byte in right direction
            if
                clr r3
            is mi
                shla r1
                # If an overflow happens, shift again w/ carry now
                # Set offset to -1 
                if  
                is cs
                    shl r1
                    ldi r3, -1
                fi
            else
                shra r1
                # If an overflow happens, shift again w/ carry now
                # Set offset to 1 
                if
                is cs
                    shr r1
                    ldi r3, 1
                fi
            fi
            # Save new player byte
            st r2, r1
        else
            shla r3
            shla r3
        fi
        # Adjust player offset based on register r3
        # Load player offset to r0
        ldi r2, player_offset
        ld r2, r0
        add r3, r0
        st r2, r0

draw:
        # Assumptions:
        # Player offset is in r0
        # Player byte is in r1
        ldi r3, display
        add r3, r0
        ldi r3, 0x80
        while
            tst r2
        stays nz
            shr r3
            dec r2
        wend

        ld r0, r1
        st r0, r3

        ldi r2, flush
        st r2, r3
        
        st r0, r1
    wend
	
	halt

define player_offset 0x00
define player_byte 0x01

    asect 0x5e
keyboard:

    asect 0x5f
flush:
    
    asect 0x60
display:
	end
